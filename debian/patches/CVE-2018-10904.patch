From: Markus Koschany <apo@debian.org>
Date: Wed, 19 Sep 2018 12:56:38 +0200
Subject: CVE-2018-10904

Origin: https://review.gluster.org/21072
---
 tests/bugs/io-stats-1322825.t         | 67 +++++++++++++++++++++++++++++++++++
 xlators/debug/io-stats/src/io-stats.c | 60 +++++++++++++++++++++----------
 2 files changed, 108 insertions(+), 19 deletions(-)
 create mode 100644 tests/bugs/io-stats-1322825.t

diff --git a/tests/bugs/io-stats-1322825.t b/tests/bugs/io-stats-1322825.t
new file mode 100644
index 0000000..53f2d04
--- /dev/null
+++ b/tests/bugs/io-stats-1322825.t
@@ -0,0 +1,67 @@
+#!/bin/bash
+
+# Test details:
+# This is to test that the io-stat-dump xattr is not set on the brick,
+# against the path that is used to trigger the stats dump.
+# Additionally it also tests if as many io-stat dumps are generated as there
+# are io-stat xlators in the graphs, which is 2 by default
+
+. $(dirname $0)/../../include.rc
+
+cleanup;
+
+TEST glusterd
+TEST pidof glusterd
+
+# Covering replication and distribution in the test
+TEST $CLI volume create $V0 replica 2 $H0:$B0/${V0}{1..4}
+TEST $CLI volume start $V0
+TEST $GFS -s $H0 --volfile-id $V0 $M0
+
+# Generate some activity for the stats to produce something useful
+TEST $CLI volume profile $V0 start
+TEST mkdir $M0/dir1
+
+# Generate the stat dump across the io-stat instances
+TEST setfattr -n trusted.io-stats-dump -v io-stats-1322825 $M0
+
+# Check if $M0 is clean w.r.t xattr information
+# TODO: if there are better ways to check we really get no attr error, please
+# correct the following.
+getfattr -n trusted.io-stats-dump $B0/${V0}1 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}2 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}3 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}4 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+
+# Check if we have 5 io-stat files in /tmp
+EXPECT 5 ls -1 /var/run/gluster/io-stats-1322825*
+# Cleanup the 5 generated files
+rm -f /var/run/gluster/io-stats-1322825*
+
+# Rinse and repeat above for a directory
+TEST setfattr -n trusted.io-stats-dump -v io-stats-1322825 $M0/dir1
+getfattr -n trusted.io-stats-dump $B0/${V0}1/dir1 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}2/dir1 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}3/dir1 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+getfattr -n trusted.io-stats-dump $B0/${V0}4/dir1 2>&1 | grep -qi "no such attribute"
+ret=$(echo $?)
+EXPECT 0 echo $ret
+
+EXPECT 5 ls -1 /var/run/gluster/io-stats-1322825*
+rm -f /var/run/gluster/io-stats-1322825*
+
+cleanup;
diff --git a/xlators/debug/io-stats/src/io-stats.c b/xlators/debug/io-stats/src/io-stats.c
index 3ca5775..0213c1c 100644
--- a/xlators/debug/io-stats/src/io-stats.c
+++ b/xlators/debug/io-stats/src/io-stats.c
@@ -51,6 +51,8 @@ typedef enum {
         IOS_STATS_TYPE_MAX
 }ios_stats_type_t;
 
+#define IOS_STATS_DUMP_DIR "/run/gluster"
+
 typedef enum {
         IOS_STATS_THRU_READ,
         IOS_STATS_THRU_WRITE,
@@ -2172,7 +2174,6 @@ io_stats_fsync (call_frame_t *frame, xlator_t *this,
         return 0;
 }
 
-
 int
 conditional_dump (dict_t *dict, char *key, data_t *value, void *data)
 {
@@ -2185,31 +2186,52 @@ conditional_dump (dict_t *dict, char *key, data_t *value, void *data)
         char                 *filename = NULL;
         FILE                 *logfp = NULL;
         struct ios_dump_args args = {0};
+        int                  namelen, dirlen;
+        char                 *path_in_value = NULL;
+        char                 *slash_ptr = NULL;
 
         stub  = data;
         this  = stub->this;
 
-        filename = alloca (value->len + 1);
-        memset (filename, 0, value->len + 1);
-        memcpy (filename, data_to_str (value), value->len);
+        path_in_value = data_to_str (value);
 
-        if (fnmatch ("*io*stat*dump", key, 0) == 0) {
+        if (strstr (path_in_value, "../")) {
+                gf_log (this->name, GF_LOG_ERROR,
+                        "%s: no \"../\" allowed in path", path_in_value);
+                return -1;
+        }
+        dirlen = strlen (IOS_STATS_DUMP_DIR);
+        namelen = (dirlen + value->len + strlen (this->name) + 3);
+        /* +3 for '/', '.' and '\0' added in snprintf below*/
 
-                if (!strncmp (filename, "", 1)) {
-                        gf_log (this->name, GF_LOG_ERROR, "No filename given");
-                        return -1;
-                }
-                logfp = fopen (filename, "w+");
-                if (!logfp) {
-                        gf_log (this->name, GF_LOG_ERROR, "failed to open %s "
-                                "for writing", filename);
-                        return -1;
-                }
-                (void) ios_dump_args_init (&args, IOS_DUMP_TYPE_FILE,
-                                           logfp);
-                io_stats_dump (this, &args);
-                fclose (logfp);
+        filename = alloca (namelen);
+
+        snprintf (filename, namelen, "%s/%s.%s", IOS_STATS_DUMP_DIR,
+                  path_in_value, this->name);
+
+        /* convert any slashes to '-' so that fopen works correctly */
+        slash_ptr = strchr (filename + dirlen + 1, '/');
+        while (slash_ptr) {
+                *slash_ptr = '-';
+                slash_ptr = strchr (slash_ptr, '/');
         }
+
+
+        if (!strncmp (filename, "", 1)) {
+                gf_log (this->name, GF_LOG_ERROR, "No filename given");
+                return -1;
+        }
+        logfp = fopen (filename, "w+");
+        if (!logfp) {
+                gf_log (this->name, GF_LOG_ERROR, "failed to open %s "
+                        "for writing", filename);
+                return -1;
+        }
+        (void) ios_dump_args_init (&args, IOS_DUMP_TYPE_FILE,
+                                   logfp);
+        io_stats_dump (this, &args);
+        fclose (logfp);
+
         return 0;
 }
 
